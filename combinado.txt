=== Archivo:./combine_and_obfuscate.py ===
import osdef combinar_archivos(directorio_raiz, archivo_salida):    with open(archivo_salida, 'w') as archivo_final:        for root, _, files in os.walk(directorio_raiz):            for file in files:                if file.endswith('.py'):                    ruta_completa = os.path.join(root, file)                    try:                        with open(ruta_completa, 'r') as archivo:                            contenido = archivo.read().replace("\n", "")                            archivo_final.write(f"=== Archivo:{ruta_completa} ===\n{contenido}\n")                    except Exception as e:                        print(f"Error al procesar {ruta_completa}: {e}")if __name__ == "__main__":    directorio_raiz = '.'    archivo_salida = 'combinado.txt'    combinar_archivos(directorio_raiz, archivo_salida)    print(f"Archivos combinados en {archivo_salida}")
=== Archivo:./backend/app /models.py ===
from sqlalchemy import Column, Integer, String, Text, ForeignKey, DateTime, Booleanfrom sqlalchemy.sql import funcfrom sqlalchemy.orm import relationshipfrom .database import Baseclass User(Base):    __tablename__ = "users"    id = Column(Integer, primary_key=True, index=True)    username = Column(String, unique=True, index=True)    email = Column(String, unique=True, index=True)    password = Column(String)    profile_image = Column(String, default="default_profile_image.png")    # Relaciones    posts = relationship("Post", back_populates="user")    comments = relationship("Comment", back_populates="user")    likes = relationship("Like", back_populates="user")    followers = relationship("Follower", foreign_keys="Follower.followed_id", back_populates="followed_user")    following = relationship("Follower", foreign_keys="Follower.follower_id", back_populates="follower_user")    sent_messages = relationship("Message", foreign_keys="Message.sender_id", back_populates="sender")    received_messages = relationship("Message", foreign_keys="Message.receiver_id", back_populates="receiver")class Post(Base):    __tablename__ = "posts"    id = Column(Integer, primary_key=True, index=True)    content = Column(Text, nullable=False)    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)    created_at = Column(DateTime, default=func.now())    # Relaciones    user = relationship("User", back_populates="posts")    comments = relationship("Comment", back_populates="post")    likes = relationship("Like", back_populates="post")class Comment(Base):    __tablename__ = "comments"    id = Column(Integer, primary_key=True, index=True)    content = Column(Text, nullable=False)    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)    post_id = Column(Integer, ForeignKey("posts.id"), nullable=False)    created_at = Column(DateTime, default=func.now())    # Relaciones    user = relationship("User", back_populates="comments")    post = relationship("Post", back_populates="comments")class Like(Base):    __tablename__ = "likes"    id = Column(Integer, primary_key=True, index=True)    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)    post_id = Column(Integer, ForeignKey("posts.id"), nullable=False)    created_at = Column(DateTime, default=func.now())    # Relaciones    user = relationship("User", back_populates="likes")    post = relationship("Post", back_populates="likes")class Follower(Base):    __tablename__ = "followers"    id = Column(Integer, primary_key=True, index=True)    follower_id = Column(Integer, ForeignKey("users.id"), nullable=False)    followed_id = Column(Integer, ForeignKey("users.id"), nullable=False)    created_at = Column(DateTime, default=func.now())    # Relaciones    follower_user = relationship("User", foreign_keys=[follower_id], back_populates="following")    followed_user = relationship("User", foreign_keys=[followed_id], back_populates="followers")class Message(Base):    __tablename__ = "messages"    id = Column(Integer, primary_key=True, index=True)    content = Column(Text, nullable=False)    sender_id = Column(Integer, ForeignKey("users.id"), nullable=False)    receiver_id = Column(Integer, ForeignKey("users.id"), nullable=False)    created_at = Column(DateTime, default=func.now())    is_read = Column(Boolean, default=False)    # Relaciones    sender = relationship("User", foreign_keys=[sender_id], back_populates="sent_messages")    receiver = relationship("User", foreign_keys=[receiver_id], back_populates="received_messages")
=== Archivo:./backend/app /crud.py ===
from sqlalchemy.orm import Sessionfrom . import models, schemasdef create_user(db: Session, user: schemas.UserCreate):    db_user = models.User(        username=user.username,        email=user.email,        password=user.password,        profile_image=user.profile_image    )    db.add(db_user)    db.commit()    db.refresh(db_user)    return db_userdef get_user_by_username(db: Session, username: str):    return db.query(models.User).filter(models.User.username == username).first()def create_post(db: Session, post: schemas.PostCreate, user_id: int):    db_post = models.Post(        content=post.content,        user_id=user_id    )    db.add(db_post)    db.commit()    db.refresh(db_post)    return db_postdef get_posts(db: Session, skip: int = 0, limit: int = 10):    return db.query(models.Post).offset(skip).limit(limit).all()def create_comment(db: Session, comment: schemas.CommentCreate, user_id: int):    db_comment = models.Comment(        content=comment.content,        user_id=user_id,        post_id=comment.post_id    )    db.add(db_comment)    db.commit()    db.refresh(db_comment)    return db_commentdef create_like(db: Session, like: schemas.LikeCreate, user_id: int):    db_like = models.Like(        user_id=user_id,        post_id=like.post_id    )    db.add(db_like)    db.commit()    db.refresh(db_like)    return db_likedef create_follower(db: Session, follower: schemas.FollowerCreate, user_id: int):    db_follower = models.Follower(        follower_id=user_id,        followed_id=follower.followed_id    )    db.add(db_follower)    db.commit()    db.refresh(db_follower)    return db_followerdef create_message(db: Session, message: schemas.MessageCreate, user_id: int):    db_message = models.Message(        content=message.content,        sender_id=user_id,        receiver_id=message.receiver_id    )    db.add(db_message)    db.commit()    db.refresh(db_message)    return db_messagedef get_users_to_follow(db: Session, user_id: int, skip: int = 0, limit: int = 10):    # Obtener usuarios que no sigues    return db.query(models.User).filter(models.User.id != user_id).offset(skip).limit(limit).all()def is_following(db: Session, follower_id: int, followed_id: int) -> bool:    return db.query(models.Follower).filter(        models.Follower.follower_id == follower_id,        models.Follower.followed_id == followed_id    ).first() is not None
=== Archivo:./backend/app /scraper.py ===

=== Archivo:./backend/app /schemas.py ===
from pydantic import BaseModelfrom typing import Optionalclass UserBase(BaseModel):    username: str    email: strclass UserCreate(BaseModel):    username: str    email: str    password: str    profile_image: Optional[str]class User(UserBase):    id: int    class Config:        orm_mode = Trueclass UserCreate(BaseModel):    username: str    email: str    password: str    profile_image: Optional[str] = Noneclass PostCreate(BaseModel):    content: strclass CommentCreate(BaseModel):    content: str    post_id: intclass LikeCreate(BaseModel):    post_id: intclass FollowerCreate(BaseModel):    followed_id: intclass MessageCreate(BaseModel):    content: str    receiver_id: int
=== Archivo:./backend/app /database.py ===
from sqlalchemy import create_enginefrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import sessionmakerSQLALCHEMY_DATABASE_URL = "postgresql://user:password@db/red_social"engine = create_engine(SQLALCHEMY_DATABASE_URL)SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)Base = declarative_base()
=== Archivo:./backend/app /main.py ===
from fastapi import FastAPI, Request, Depends, Form, status, HTTPException, File, UploadFile, Cookiefrom fastapi.responses import HTMLResponse, RedirectResponsefrom fastapi.templating import Jinja2Templatesfrom sqlalchemy.orm import Sessionfrom pathlib import Pathfrom fastapi.staticfiles import StaticFilesfrom . import models, schemas, crudfrom .database import SessionLocal, engine# Inicializar la base de datosmodels.Base.metadata.create_all(bind=engine)# Configuración de FastAPI y archivos estáticosapp = FastAPI()app.mount("/static", StaticFiles(directory="app/static"), name="static")# Directorio para imágenes de perfilPROFILE_IMAGES_DIR = Path("app/static/profile_images")PROFILE_IMAGES_DIR.mkdir(parents=True, exist_ok=True)# Configuración de plantillas Jinja2templates = Jinja2Templates(directory="app/templates")# Dependencia para la sesión de base de datosdef get_db():    db = SessionLocal()    try:        yield db    finally:        db.close()# Función para obtener el usuario autenticado desde la cookiedef get_current_user(username: str = Cookie(None), db: Session = Depends(get_db)):    if not username:        return None    return crud.get_user_by_username(db, username)# Ruta principal@app.get("/home", response_class=HTMLResponse)async def home(request: Request, db: Session = Depends(get_db), user: schemas.User = Depends(get_current_user)):    posts = crud.get_posts(db)    users_to_follow = crud.get_users_to_follow(db, user.id if user else None)    return templates.TemplateResponse("home.html", {        "request": request,        "posts": posts,        "users_to_follow": users_to_follow,        "user": user,        "crud": crud,  # Pasar el módulo crud a la plantilla        "db": db      })# Mostrar formulario de registro@app.get("/", response_class=HTMLResponse)async def show_register_form(request: Request):    return templates.TemplateResponse("register.html", {"request": request, "message": ""})# Procesar registro de usuario@app.post("/register", response_class=RedirectResponse)async def register(    request: Request,    username: str = Form(...),    email: str = Form(...),    password: str = Form(...),    profile_image: UploadFile = File(None),    db: Session = Depends(get_db)):    if crud.get_user_by_username(db, username):        return templates.TemplateResponse("register.html", {"request": request, "message": "El usuario ya existe"})    profile_image_filename = None    if profile_image:        file_extension = profile_image.filename.split(".")[-1]        profile_image_filename = f"{username}_profile.{file_extension}"        profile_image_path = PROFILE_IMAGES_DIR / profile_image_filename        with open(profile_image_path, "wb") as buffer:            buffer.write(await profile_image.read())    user = schemas.UserCreate(username=username, email=email, password=password, profile_image=profile_image_filename)    crud.create_user(db, user)    response = RedirectResponse(url="/login", status_code=status.HTTP_303_SEE_OTHER)    return response# Mostrar formulario de inicio de sesión@app.get("/login", response_class=HTMLResponse)async def show_login_form(request: Request):    return templates.TemplateResponse("login.html", {"request": request, "message": ""})# Procesar inicio de sesión@app.post("/login", response_class=RedirectResponse)async def login(    request: Request,    username: str = Form(...),    password: str = Form(...),    db: Session = Depends(get_db)):    user = crud.get_user_by_username(db, username)    if user and user.password == password:        response = RedirectResponse(url="/home", status_code=status.HTTP_303_SEE_OTHER)        response.set_cookie(key="username", value=username)        return response    return templates.TemplateResponse("login.html", {"request": request, "message": "Credenciales incorrectas"})# Mostrar perfil de usuario@app.get("/profile", response_class=HTMLResponse)async def show_profile(request: Request, user: schemas.User = Depends(get_current_user)):    if not user:        return RedirectResponse(url="/login", status_code=status.HTTP_303_SEE_OTHER)    return templates.TemplateResponse("profile.html", {"request": request, "user": user})# Cerrar sesión@app.get("/logout", response_class=RedirectResponse)async def logout():    response = RedirectResponse(url="/", status_code=status.HTTP_303_SEE_OTHER)    response.delete_cookie(key="username")    return response# Crear post@app.post("/create_post", response_class=RedirectResponse)async def create_post(    request: Request,    content: str = Form(...),    db: Session = Depends(get_db),    user: schemas.User = Depends(get_current_user)):    if not user:        return RedirectResponse(url="/login", status_code=status.HTTP_303_SEE_OTHER)        post = schemas.PostCreate(content=content)    crud.create_post(db, post, user.id)    return RedirectResponse(url="/home", status_code=status.HTTP_303_SEE_OTHER)# Agregar comentario@app.post("/add_comment/{post_id}", response_class=RedirectResponse)async def add_comment(    request: Request,    post_id: int,    content: str = Form(...),    db: Session = Depends(get_db),    user: schemas.User = Depends(get_current_user)):    if not user:        return RedirectResponse(url="/login", status_code=status.HTTP_303_SEE_OTHER)    comment = schemas.CommentCreate(content=content, post_id=post_id)    crud.create_comment(db, comment, user.id)    return RedirectResponse(url="/home", status_code=status.HTTP_303_SEE_OTHER)# Dar like a un post@app.post("/like_post/{post_id}", response_class=RedirectResponse)async def like_post(    request: Request,    post_id: int,    db: Session = Depends(get_db),    user: schemas.User = Depends(get_current_user)):    if not user:        return RedirectResponse(url="/login", status_code=status.HTTP_303_SEE_OTHER)    like = schemas.LikeCreate(post_id=post_id)    crud.create_like(db, like, user.id)    return RedirectResponse(url="/home", status_code=status.HTTP_303_SEE_OTHER)# Seguir a un usuario@app.post("/follow_user/{user_id}", response_class=RedirectResponse)async def follow_user(    request: Request,    user_id: int,    db: Session = Depends(get_db),    user: schemas.User = Depends(get_current_user)):    if not user:        return RedirectResponse(url="/login", status_code=status.HTTP_303_SEE_OTHER)    # Verificar si el usuario ya sigue al otro usuario    if crud.is_following(db, user.id, user_id):        # Si ya lo sigue, puedes devolver un mensaje o simplemente redirigir        return RedirectResponse(url="/home", status_code=status.HTTP_303_SEE_OTHER)    follow = schemas.FollowerCreate(followed_id=user_id)    crud.create_follower(db, follow, user.id)    return RedirectResponse(url="/home", status_code=status.HTTP_303_SEE_OTHER)
=== Archivo:./backend/app /config.py ===

=== Archivo:./backend/app /__init__.py ===

